"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const Utils_1 = require("../Utils");
const File_1 = require("./File");
const fs = require("fs");
const Config_1 = require("../Config");
const CACHED = {};
class TypescriptConfig {
    constructor(context) {
        this.context = context;
    }
    getConfig() {
        this.read();
        return this.config;
    }
    defaultSetup() {
        const compilerOptions = this.config.compilerOptions = this.config.compilerOptions || {};
        if (this.context.useSourceMaps) {
            compilerOptions.sourceMap = true;
            compilerOptions.inlineSources = true;
        }
        if (this.context.forcedLanguageLevel) {
            this.forceCompilerTarget(this.context.forcedLanguageLevel);
        }
    }
    forceCompilerTarget(level) {
        this.context.log.echoInfo(`Typescript forced script target: ${File_1.ScriptTarget[level]}`);
        const compilerOptions = this.config.compilerOptions = this.config.compilerOptions || {};
        compilerOptions.target = File_1.ScriptTarget[level];
    }
    setConfigFile(customTsConfig) {
        this.customTsConfig = customTsConfig;
    }
    initializeConfig() {
        const compilerOptions = this.config.compilerOptions;
        compilerOptions.jsx = "react";
        compilerOptions.importHelpers = true;
        compilerOptions.emitDecoratorMetadata = true;
        compilerOptions.experimentalDecorators = true;
        const targetFile = path.join(this.context.homeDir, "tsconfig.json");
        this.context.log.echoInfo(`Generating recommended tsconfig.json:  ${targetFile}`);
        fs.writeFileSync(targetFile, JSON.stringify(this.config, null, 2));
    }
    verifyTsLib() {
        if (this.config.compilerOptions.importHelpers === true) {
            const tslibPath = path.join(Config_1.Config.NODE_MODULES_DIR, "tslib");
            if (!fs.existsSync(tslibPath)) {
                this.context.log.echoWarning(`You have enabled importHelpers. Please install tslib - https://github.com/Microsoft/tslib`);
            }
        }
    }
    read() {
        const cacheKey = (typeof this.customTsConfig === "string" ? this.customTsConfig : this.context.homeDir)
            + this.context.target + this.context.languageLevel;
        if (CACHED[cacheKey]) {
            this.config = CACHED[cacheKey];
        }
        else {
            let url, configFile;
            let config = {
                compilerOptions: {},
            };
            ;
            let configFileFound = false;
            let tsConfigOverride;
            if (typeof this.customTsConfig === "string") {
                configFile = Utils_1.ensureUserPath(this.customTsConfig);
            }
            else {
                url = path.join(this.context.homeDir, "tsconfig.json");
                let tsconfig = Utils_1.findFileBackwards(url, this.context.appRoot);
                if (tsconfig) {
                    configFileFound = true;
                    configFile = tsconfig;
                }
            }
            if (configFile) {
                this.context.log.echoInfo(`Typescript config file:  ${configFile.replace(this.context.appRoot, "")}`);
                configFileFound = true;
                config = require(configFile);
            }
            if (Array.isArray(this.customTsConfig)) {
                tsConfigOverride = this.customTsConfig[0];
            }
            config.compilerOptions.module = "commonjs";
            if (!('target' in config.compilerOptions)) {
                config.compilerOptions.target = File_1.ScriptTarget[this.context.languageLevel];
            }
            if (tsConfigOverride) {
                config.compilerOptions = Object.assign(config.compilerOptions, tsConfigOverride);
            }
            if (config.compilerOptions.allowSyntheticDefaultImports !== undefined) {
                if (this.context.fuse && this.context.fuse.producer) {
                    this.context.fuse.producer.allowSyntheticDefaultImports = config.compilerOptions.allowSyntheticDefaultImports;
                    ;
                }
            }
            this.config = config;
            this.defaultSetup();
            if (!configFileFound && this.context.ensureTsConfig === true) {
                this.initializeConfig();
            }
            if (this.context.ensureTsConfig === true) {
                this.verifyTsLib();
            }
            this.context.log.echoInfo(`Typescript script target: ${config.compilerOptions.target}`);
            CACHED[cacheKey] = this.config;
        }
    }
}
exports.TypescriptConfig = TypescriptConfig;
